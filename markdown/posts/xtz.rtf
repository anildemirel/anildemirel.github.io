{\rtf1\ansi\ansicpg1254\cocoartf2707
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\froman\fcharset0 Times-Bold;\f1\froman\fcharset0 Times-Roman;\f2\fmodern\fcharset0 Courier;
\f3\froman\fcharset0 Times-Italic;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red0\green0\blue233;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\cssrgb\c0\c0\c93333;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sa321\partightenfactor0

\f0\b\fs48 \cf0 \expnd0\expndtw0\kerning0
Self Aware Program\
A Classical Exercise\
\pard\pardeftab720\sa240\partightenfactor0

\f1\b0\fs24 \cf0 A computer program which produces its own source code is called a quine, named after the logician Willard Van Orman Quine.\
\pard\pardeftab720\sa240\partightenfactor0

\f0\b \cf0 Exercise:
\f1\b0  Write a quine in your favorite programming language.\
If you haven\'92t solved this exercise before, I urge you to stop right now and give it a try.\
To give you an idea of why this is an interesting problem, let us try to solve it in a naive way. Instead of using an actual programming language I will use pseudocode to keep things simple.\
The obvious candidate of a quine is\
\pard\pardeftab720\partightenfactor0

\f2\fs26 \cf0 Print your own source code\
\pard\pardeftab720\sa240\partightenfactor0

\f1\fs24 \cf0 This looks like cheating but actually there are languages which allow this. For instance\
\pard\pardeftab720\partightenfactor0

\f2\fs26 \cf0 10 List\
\pard\pardeftab720\sa240\partightenfactor0

\f1\fs24 \cf0 is a valid GWBasic program which, when run, prints 
\f2\fs26 10 List
\f1\fs24  on the screen. Actually, in GWBasic, 
\f3\i any
\f1\i0  code which starts with 
\f2\fs26 10 List
\f1\fs24  is a quine.\
So, to make things less trivial and more generic, let us restrict ourselves to text manipulations. In this case, the first candidate is\
\pard\pardeftab720\partightenfactor0

\f2\fs26 \cf0 Print "Print"\
\pard\pardeftab720\sa240\partightenfactor0

\f1\fs24 \cf0 The output of this code is simply 
\f2\fs26 Print
\f1\fs24 . So it doesn\'92t work. Seeing this, you may try\
\pard\pardeftab720\partightenfactor0

\f2\fs26 \cf0 Print "Print "Print""\
\pard\pardeftab720\sa240\partightenfactor0

\f1\fs24 \cf0 This time the output is 
\f2\fs26 Print "Print"
\f1\fs24 . Failed again. Actually, any code of the form 
\f2\fs26 Print "<any kind of fixed text>"
\f1\fs24  will fail as the source code is strictly longer than the text it prints. Now here is an idea to circumvent this: We can use the the given text, or its parts, more than once! So let us try a program like this:\
\pard\pardeftab720\partightenfactor0

\f2\fs26 \cf0 Let A be the following text:\
"<there is going to be a text here>"\
<there are going to be commands here explaining what to do with A>\
\pard\pardeftab720\sa240\partightenfactor0

\f1\fs24 \cf0 As we will construct the source code using the parts of the text A, the first line of the code should be a part of A. So our program should look like this:\
\pard\pardeftab720\partightenfactor0

\f2\fs26 \cf0 Let A be the following text:\
"Let A be the following text:\
<there are going to be more lines here>"\
<there are going to be commands here explaining what to do with A>\
\pard\pardeftab720\sa240\partightenfactor0

\f1\fs24 \cf0 Of course, we will print the first line. Thus we should have a program like this:\
\pard\pardeftab720\partightenfactor0

\f2\fs26 \cf0 Let A be the following text:\
"Let A be the following text:\
<there are going to be more lines here>"\
Print the first line of A\
<there are going to be more commands here>\
\pard\pardeftab720\sa240\partightenfactor0

\f1\fs24 \cf0 Obviously the command 
\f2\fs26 Print the first line of A
\f1\fs24  should appear somewhere in A. So let\'92s add it to A to obtain\
\pard\pardeftab720\partightenfactor0

\f2\fs26 \cf0 Let A be the following text:\
"Let A be the following text:\
Print the first line of A\
<there are going to be more lines here>"\
Print the first line of A\
<there are going to be more commands here>\
\pard\pardeftab720\sa240\partightenfactor0

\f1\fs24 \cf0 Now the second printing command should print what comes after the first line. But this is simply the text A in quotation. Therefore we should have\
\pard\pardeftab720\partightenfactor0

\f2\fs26 \cf0 Let A be the following text:\
"Let A be the following text:\
Print the first line of A\
<there are going to be more lines here>"\
Print the first line of A\
Print A in quotation\
<there are going to be more commands here>\
\pard\pardeftab720\sa240\partightenfactor0

\f1\fs24 \cf0 Again these commands should appear in A. So we have\
\pard\pardeftab720\partightenfactor0

\f2\fs26 \cf0 Let A be the following text:\
"Let A be the following text:\
Print the first line of A\
Print A in quotation\
<there are going to be more lines here>"\
Print the first line of A\
Print A in quotation\
<there are going to be more commands here>\
\pard\pardeftab720\sa240\partightenfactor0

\f1\fs24 \cf0 Note that, up until now, all the steps we took were pretty much forced. The final step will be a little different and require a tid bit of creativity. Here is our finished quine:\
\pard\pardeftab720\partightenfactor0

\f2\fs26 \cf0 Let A be the following text:\
"Let A be the following text:\
Print the first line of A\
Print A in quotation\
Print A except for its first line"\
Print the first line of A\
Print A in quotation\
Print A except for its first line\
\pard\pardeftab720\sa240\partightenfactor0

\f1\fs24 \cf0 As an exercise, you may translate this quine into a real programming language. Even though the quine above has the essential idea, you may still need to deal with a few language specific details such as escaping quotation marks. Here is one for you in Haskell meant to be evaluated in repl.\
\pard\pardeftab720\partightenfactor0

\f2\fs26 \cf0 let x = ["let x = ", " in putStr (x !! 0) >> putStr (show x) >> putStr (x !! 1)"] in putStr (x !! 0) >> putStr (show x) >> putStr (x !! 1)\
\pard\pardeftab720\sa240\partightenfactor0

\f1\fs24 \cf0 Now this was fun, bu also ad-hoc. The natural question to ask here whether there is a principled way of writing, not only quines, but programs which have some kind of access to their own source code. The answer is yes and this follows from one of the most fundamental results in recursion theory, the recursion theorem.\
\pard\pardeftab720\sa321\partightenfactor0

\f0\b\fs48 \cf0 Kleene\'92s Recursion Theorem\
\pard\pardeftab720\sa240\partightenfactor0

\f1\b0\fs24 \cf0 I want to work with a Turing complete programming language. Luckily, what we need is essentially what I described in the first section of {\field{\*\fldinst{HYPERLINK "https://sonatsuer.github.io/kolmogorov-complexity/2018/05/21/kolmogorov-complexity-1.html"}}{\fldrslt \cf3 \ul \ulc3 Kolmogorov Complexity (1/2)}}. The differences are that we do not need \\(\\mathcal\{L\}\\) to contain UTF-8 characters and we do not need an assumption on the way we represent natural numbers.\
Let \\(\\mathcal\{M\}\\) be the set of all strings from \\(\\mathcal\{L\}\\) and let \\(\\mathcal\{C\}(n)\\) be the set of all source codes expecting \\(n\\) inputs, where \\(n\\) is a natural number. Then, for each \\(c\\in\\mathcal\{C\}(n)\\), we have a partial function \\(f_c\\) from \\(\\mathcal\{M\}^n\\) to \\(\\mathcal\{M\}\\), which is simply the partial function computed by the source code \\(c\\). These functions are called the computable partial functions.\
Let us start with a simple but useful lemma.\
\pard\pardeftab720\sa240\partightenfactor0

\f0\b \cf0 Lemma:
\f1\b0  There is a computable function \\(s\\) such that for any \\(x\\in\\mathcal\{M\}\\) and \\(c\\in\\mathcal\{C\}(2)\\) we have \\(s(c,x)\\in\\mathcal\{C\}(1)\\) and \\[ f_c(x,y) = f_\{s(c,x)\}(y). \\]}
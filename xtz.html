<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>xtz</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
  </style>
  <link rel="stylesheet" href="./assets/format.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">xtz</h1>
</header>
<p><strong>Self Aware Program edited</strong><br />
<strong>A Classical Exercise</strong><br />
A computer program which produces its own source code is called a quine,
named after the logician Willard Van Orman Quine.<br />
<strong>Exercise:</strong> Write a quine in your favorite programming
language.<br />
If you haven’t solved this exercise before, I urge you to stop right now
and give it a try.<br />
To give you an idea of why this is an interesting problem, let us try to
solve it in a naive way. Instead of using an actual programming language
I will use pseudocode to keep things simple.<br />
The obvious candidate of a quine is<br />
<code>Print your own source code</code><br />
This looks like cheating but actually there are languages which allow
this. For instance<br />
<code>10 List</code><br />
is a valid GWBasic program which, when run, prints <code>10 List</code>
on the screen. Actually, in GWBasic, <em>any</em> code which starts with
<code>10 List</code> is a quine.<br />
So, to make things less trivial and more generic, let us restrict
ourselves to text manipulations. In this case, the first candidate
is<br />
<code>Print "Print"</code><br />
The output of this code is simply <code>Print</code>. So it doesn’t
work. Seeing this, you may try<br />
<code>Print "Print "Print""</code><br />
This time the output is <code>Print "Print"</code>. Failed again.
Actually, any code of the form
<code>Print "&lt;any kind of fixed text&gt;"</code> will fail as the
source code is strictly longer than the text it prints. Now here is an
idea to circumvent this: We can use the the given text, or its parts,
more than once! So let us try a program like this:<br />
<code>Let A be the following text:</code><br />
<code>"&lt;there is going to be a text here&gt;"</code><br />
<code>&lt;there are going to be commands here explaining what to do with A&gt;</code><br />
As we will construct the source code using the parts of the text A, the
first line of the code should be a part of A. So our program should look
like this:<br />
<code>Let A be the following text:</code><br />
<code>"Let A be the following text:</code><br />
<code>&lt;there are going to be more lines here&gt;"</code><br />
<code>&lt;there are going to be commands here explaining what to do with A&gt;</code><br />
Of course, we will print the first line. Thus we should have a program
like this:<br />
<code>Let A be the following text:</code><br />
<code>"Let A be the following text:</code><br />
<code>&lt;there are going to be more lines here&gt;"</code><br />
<code>Print the first line of A</code><br />
<code>&lt;there are going to be more commands here&gt;</code><br />
Obviously the command <code>Print the first line of A</code> should
appear somewhere in A. So let’s add it to A to obtain<br />
<code>Let A be the following text:</code><br />
<code>"Let A be the following text:</code><br />
<code>Print the first line of A</code><br />
<code>&lt;there are going to be more lines here&gt;"</code><br />
<code>Print the first line of A</code><br />
<code>&lt;there are going to be more commands here&gt;</code><br />
Now the second printing command should print what comes after the first
line. But this is simply the text A in quotation. Therefore we should
have<br />
<code>Let A be the following text:</code><br />
<code>"Let A be the following text:</code><br />
<code>Print the first line of A</code><br />
<code>&lt;there are going to be more lines here&gt;"</code><br />
<code>Print the first line of A</code><br />
<code>Print A in quotation</code><br />
<code>&lt;there are going to be more commands here&gt;</code><br />
Again these commands should appear in A. So we have<br />
<code>Let A be the following text:</code><br />
<code>"Let A be the following text:</code><br />
<code>Print the first line of A</code><br />
<code>Print A in quotation</code><br />
<code>&lt;there are going to be more lines here&gt;"</code><br />
<code>Print the first line of A</code><br />
<code>Print A in quotation</code><br />
<code>&lt;there are going to be more commands here&gt;</code><br />
Note that, up until now, all the steps we took were pretty much forced.
The final step will be a little different and require a tid bit of
creativity. Here is our finished quine:<br />
<code>Let A be the following text:</code><br />
<code>"Let A be the following text:</code><br />
<code>Print the first line of A</code><br />
<code>Print A in quotation</code><br />
<code>Print A except for its first line"</code><br />
<code>Print the first line of A</code><br />
<code>Print A in quotation</code><br />
<code>Print A except for its first line</code><br />
As an exercise, you may translate this quine into a real programming
language. Even though the quine above has the essential idea, you may
still need to deal with a few language specific details such as escaping
quotation marks. Here is one for you in Haskell meant to be evaluated in
repl.<br />
<code>let x = ["let x = ", " in putStr (x !! 0) &gt;&gt; putStr (show x) &gt;&gt; putStr (x !! 1)"] in putStr (x !! 0) &gt;&gt; putStr (show x) &gt;&gt; putStr (x !! 1)</code><br />
Now this was fun, bu also ad-hoc. The natural question to ask here
whether there is a principled way of writing, not only quines, but
programs which have some kind of access to their own source code. The
answer is yes and this follows from one of the most fundamental results
in recursion theory, the recursion theorem.<br />
<strong>Kleene’s Recursion Theorem</strong><br />
I want to work with a Turing complete programming language. Luckily,
what we need is essentially what I described in the first section of
<u><a
href="https://sonatsuer.github.io/kolmogorov-complexity/2018/05/21/kolmogorov-complexity-1.html">Kolmogorov
Complexity (1/2)</a></u>. The differences are that we do not need
\(\mathcal{L}\) to contain UTF-8 characters and we do not need an
assumption on the way we represent natural numbers.<br />
Let \(\mathcal{M}\) be the set of all strings from \(\mathcal{L}\) and
let \(\mathcal{C}(n)\) be the set of all source codes expecting \(n\)
inputs, where \(n\) is a natural number. Then, for each
\(c\in\mathcal{C}(n)\), we have a partial function \(f_c\) from
\(\mathcal{M}^n\) to \(\mathcal{M}\), which is simply the partial
function computed by the source code \(c\). These functions are called
the computable partial functions.<br />
Let us start with a simple but useful lemma.<br />
<strong>Lemma:</strong> There is a computable function \(s\) such that
for any \(x\in\mathcal{M}\) and \(c\in\mathcal{C}(2)\) we have
\(s(c,x)\in\mathcal{C}(1)\) and \[ f_c(x,y) = f_{s(c,x)}(y). \]</p>
</body>
</html>
